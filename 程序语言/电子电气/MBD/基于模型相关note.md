[toc]

# 基于模型的设计

## 什么叫基于模型的设计？

通过对算法建模进行软件设计的过程，都可以叫基于模型的设计。

如果想通过基于模型的设计提升软件开发团队的开发效率，提高软件品质，我觉得至少有如下几点可以考虑：

- 算法建模
- 算法模型的验证
- 文档自动化
- 代码生成
- 代码和模型的等效性验证。

### 需求分析

传统的开发过程中，我们有一个环节，需求捕获，也即，从系统需求分解出软件需求。
在基于模型的设计过程中，我们同样可以通过分析系统需求，获得软件需求。
当然，根据系统需求的详细程度，我们可以考虑是否要写专门的软件需求。
在基于模型的软件设计中，我们主要关心的是系统的 **功能需求**，或者说可以通过软件实现的功能需求。如果这部分需求在系统需求文档里已经有非常清楚的定义，那么我们可以以系统需求文档作为依据建立模型。
当然，如果系统需求不是足够清楚，那我们有必要编写专门的软件 **需求文档**。
如果不考虑Simulink/Stateflow的应用上的问题，也就是说，如果我们都是熟练的Simulink/Stateflow用户，那么建模过程的主要工作是需求分析，通俗点讲，需求弄清楚了，建模也就是非常简单的事情了。
当然，建模的时候，要考虑未来的验证、实现以及后期维护的问题。
我个人的体会，这个阶段，不要着急建模，一定要先弄清需求，另外，建模的时候，模型架构非常重要。

### 模型建模

在软件产品开发中，建模活动里，耗时最多的，就应该是需求分析了，需求分析不仅包括如何正确理解软件需求，而且要考虑如何通过模型实现，真正的画模型的时间，相比之下并不多，如果Simulink/Stateflow用的熟的话，真正打开MATLAB画模型的时间占建模阶段总时间的1/3都不到。

### 早期验证

弄清为什么要基于模型的设计，也就是要弄清楚基于模型的设计到底可以给我们带来哪些好处？
很多人会非常自然的想到，代码生成，代码生成可以提高软件开发效率。
没错，代码生成是一个很大的好处，但，代码生成不是唯一的，也不是最大的好处。
最大的好处是， **算法的早期验证**，之前NASA有研究表明，开发初期引入的bug，如果到了晚期才发现出来，那么修复这一的bug，会产生非常大的费用。所以，我们期望能够尽早的发现开发过程中引入的bug。

中国有句老话，“心急吃不了热豆腐”，“项目时间紧”或者“人手不够”不能成为我们忽略模型测试的借口

#### 验证方法：

- 评审、评审作为一种非常传统的验证方式，并不能及时发现设计过程中引入的各种错误。
- 仿真

从效率上讲，要远高于评审，仿真更容易发现设计中的问题。
仿真是可以运行的，如果我们设定一些输入，运行模型之后，我们会得到相应的输出，我们很容易观测到此时的输出是否是我们期望的输出。
另外还有好处，仿真的结果是确定的，给定输入，就会得到确定的输出，当然，期望输出也是确定的。而不像评审，同样的文字，对于不同人，可能理解成不同的含义。

#### verification and validation

Verification是考察你是否正确的做了一件事，而Validation，则是考察你是否做出了正确的东西。一个强调的是过程，一个在乎的是结果。

#### 验证步骤

- 建模标准的检查
- 评审
- 单元测试
- 快速原型

模型出来并且可以编译之后，首先要做建模标准检查，这个过程使用工具（比如MathWorks公司的Simulink Verification & Validation提供的model advisor）自动化的完成，检查过后，修改模型中不符合公司建模规则的项目。

接下来，就可以进行模型评审了，也就是说，评审的模型有两个前提，一是可以编译的，二是符合公司建模规则的。这两个前提可以帮助我们消除模型中的一些低级错误，避免在评审过程中有太多的时间花费在这些错误上。因为评审是建模的工程师和其他同事共同参与的活动，做到上述两个前提，也是对其他同事工作时间的一种尊重。
评审之后，建模的工程师会修改评审中发现的问题，问题多的话，一般会要求修改之后再进行“再评审”，直到在评审中不会发现大量问题。

接下来，我们可以使用Simulink Design Verifier进行模型的结构分析，借助于Simulink Design Verifier自动生成测试用例的功能，去检查结构上是否存在问题，比如是否有不合理的逻辑设计，是否有运行不到的分支等。

再往后，就可以进行模型单元级别的功能测试了。软件开发过程中，对单元测试的要求是很高的，一般会根据应用的安全性、可靠性要求，给出测试的覆盖率要求。

这个过程中工作量最大的应该是测试用例设计以及测试向量的生成。测试用例设计，我们一般会根据需求去设计测试用例，当然，也会结合模型结构设计测试用例，这样说来，这里的测试，已经包含了黑盒测试和白盒测试。有了测试用例，如何把测试用例转换为测试向量，这也是非常重要的环节。我们知道，在MBD开发过程中，代码都可以自动生成，其他环节，我们要努力做到自动化实现。我们可以使用MATLAB脚本开发一些转换工具用于将测试用例转换为测试向量，我们还可以通过脚本实现测试过程的自动化。

测试的指标，即测试覆盖率是否达到公司的要求或者行业的要求。

单元级别的功能测试完成之后，我们自然会进行集成测试，当然，集成测试是分阶段、有步骤的，我们可以先把一些单元模块集成为组件级，进行组件级的集成测试，然后再将组件集成为系统级，进行系统级测试。集成测试和单元测试关注的内容不同，集成测试，我们更关注于单元模块之间的借口关系、调用关系等等，所以，单元测试中要求的判定覆盖率、MCDC覆盖率等，在集成测试中没有这样的要求。
条件允许的情况下，集成测试之前或者之后，可以通过快速原型的方式和实物相连，进行测试。

集成测试通过之后，我们基本上可以认为模型或者说算法是正确的了。接下来，我们就可以进行代码生成了。

代码生成之后，会跟着做SIL、PIL、HIL等测试，所有这些In-the-Loop测试都不是必须的，工程师应该根绝项目的实际情况，选择合理的测试方案，当然，建议SIL测试不要省略，原因在于这种测试的确非常方便做，并且也的确会发现一些代码生成过程中出现的问题。

### 代码生成

代码生成的前提是模型已经是验证过的模型，或者说，是正确的模型。
正确的模型包含两层含义，模型做过足够多的验证，验证的结果都是正确的。前面提到的各种验证方式，都有必要做，对于功能测试来讲，还有必要达到足够高的覆盖率要求。
做到以上这些，就可以考虑进行代码生成工作了，代码生成是否就是按一下“Code Generation”按钮的工作呢？工程项目开发中，没那么简单，代码生成过程中，工程师要做的主要工作是数据管理工作，除此之外，还会有一些代码相关的配置，比如函数原型、比如代码文件等等。

数据管理主要是对Simulink/Stateflow模型中的两类数据进行管理，一是信号，一是参数。对应于C代码，我们可以简单的把信号对应到变量上，而参数，则是不通过程序运行而发生变化的，参数的变化，一般是通过人工调节完成的，也就是参数调节，参数调节的目的是为了选择合适的参数以得到最佳的性能。

数据管理的方式，使用的是数据对象进行数据管理，这里的“对象”二字，和我们经常听到的“面向对象编程”里面的“对象”意义相同。Simulink为用户事先定义好两个包，一个是Simulink Package，一个是mpt Package。以Simulink Package为例，包里面有类，分别为Simulink.Signal和Simulink.Parameter两个类。用户可以通过这两个类定义相应的对象（Object），然后通过类提供的属性（Property）定义数据的属性。其实这两个类里面除了属性之外，还定义了方法（Method），一般情况下，我们管理数据，使用属性就够了。

当然，不管是Simulink Package还是mtp Package，都不能完全满足用户的所有要求，所以，很多时候，需要用户定义自己的Package。依然按照面向对象里面的一些概念，我们可以从Simulink Package或者mpt Package继承并创建自己的包。
所有我们关心的数据都通过数据对象的方式做了定义之后，接下来的工作，就是按下按钮，生成代码了。

### 文档自动化

基于模型的设计，可以帮助我们实现文档自动化，至少有相当大的一部分文档可以让计算机替我们写。

## 其它问题

### 有关底层驱动的建模

我一直认为在产品化项目开发中，底层驱动是没有必要建模的。原因如下：

1. 底层驱动在Simulink环境下不能仿真；
2. 底层驱动建模需要熟悉另外一种脚本语言——TLC；
3. 产品化项目的底层软件往往很大，有些项目的底层软件甚至大于应用层软件，如此大的软件转换成Simulink下的TLC实现，不容易操作。

当然，有人会说，一旦有了底层驱动模型，就可以非常方便的实现Simulink模型到单片机hex文件的一键式实现，的确这样做貌似让整个开发过程的自动化程度得以提升，但是，不要忘记，你要开发出一个安全、可靠的底层模块库，会需要大量的时间投入，尤其在使用TLC设计的时候，TLC本身就是另外一种新的语言，同时这种语言所提供的调试环境也不尽如人意；相反，如果不使用这种一键式的模式，而是采用手工集成的方式实现自动生成的应用层代码与底层代码做集成，也是非常简单，非常轻松的事情。

总结一下，一键式的实现hex文件生成并不能明显提高开发效率，而开发出这样一个底层模块库，却需要花费大量的时间。

### 几个在环测试的说明

我们经常听到的有MIL、SIL、PIL、HIL等，在基于模型设计的开发过程中，是否都要做这些In-the-Loop测试？
我认为所有的In-the-Loop都不是一定要做的，不过，我非常建议不要省略SIL环节。

1. MIL，模型在环测试，在Simulink环境里，除建立控制器模型之外，还需要建立被控对象模型，讲控制器和被控对象连接起来并形成闭环，让控制器去控制被控对象。
是否一定要做这个In-the-Loop呢？或者说，是否一定要有被控对象模型呢？其实不一定，这取决于模型验证的可能方式。在不少应用里，控制器模型的输出是开关量，工程师可以很方便的通过设定输入并给出期望输出，这样的情况，被控对象是没必要的，比如，汽车电子里面的车身控制，控制一个灯的开或者关，只需要知道输出是ON或者OFF即可，没必要去做一个灯泡的模型放到Simulink里。
2. SIL，软件在环测试，软件在环测试，应该说是从模型在环测试引申过来的，区别只是把控制器的模型换成了由控制器模型生成的C代码编译成的S-function，SIL的目的是为了验证生成的代码和模型在功能上是否一致，或者说验证生成的代码和模型在功能上是否等效。
验证等效性，是否一定需要被控对象模型？不必要，既然验证生成的代码和模型的一致性，那只需要给生成代码和用于代码生成的模型相同的输入，比较它们在相同的输入条件下，输出是否一致即可。
3. PIL，PIL有两个目的，一是为了等效性验证，二是为了测量模型生成的代码在目标处理器上的运行时间。有关运行时间的测量，如果你选择的处理器足够强大，或者你非常把握目标代码的运行不会超限，那么PIL的意义就要打折扣了。
4. HIL测试的目的是为了验证控制器的，HIL过程中，会把被控对象的模型生成C代码并编译成可执行的文件放到工控机上运行，以便工控机替代真是的被控对象，然后把控制器和工控机连接起来，实现闭环控制，从控制器的角度上看，就相当于工作到实际控制系统之中。HIL经常被用于以下几种情形：a）被控对象非常昂贵，如果控制器不成熟会导致被控对象的损害；b）被控对象失效会危及人身安全；c）开发过程中，先开发出了控制器，而被控对象还没有开发出来。
